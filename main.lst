   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 124               		.section	.rodata.str1.1,"aMS",@progbits,1
 125               	.LC0:
 126 0000 4120 00   		.string	"A "
 127               		.text
 129               	.global	send_state
 131               	send_state:
   1:main.c        **** /*
   2:main.c        ****  * To change this license header, choose License Headers in Project Properties.
   3:main.c        ****  * To change this template file, choose Tools | Templates
   4:main.c        ****  * and open the template in the editor.
   5:main.c        ****  */
   6:main.c        **** 
   7:main.c        **** /* 
   8:main.c        ****  * File:   main.c
   9:main.c        ****  * Author: krille0x7c2
  10:main.c        ****  *
  11:main.c        ****  * Created on November 21, 2015, 9:11 PM
  12:main.c        ****  */
  13:main.c        **** #define F_CPU 16000000UL
  14:main.c        **** #include <stdio.h>
  15:main.c        **** #include <stdlib.h>
  16:main.c        **** #include <avr/io.h>
  17:main.c        **** #include <avr/interrupt.h>
  18:main.c        **** #include <util/delay.h>
  19:main.c        **** 
  20:main.c        **** #include "UART.h"
  21:main.c        **** 
  22:main.c        **** int entry_state(void);
  23:main.c        **** int ping_state(void);
  24:main.c        **** int send_state(void);
  25:main.c        **** int exit_state(void);
  26:main.c        **** 
  27:main.c        **** /*?*/
  28:main.c        **** int (*state[]) (void) = {entry_state, ping_state, send_state, exit_state};
  29:main.c        **** 
  30:main.c        **** /*List the different state codes*/
  31:main.c        **** enum state_codes {entry, ping, send, end};
  32:main.c        **** /*List avaliable return codes*/
  33:main.c        **** enum ret_codes {ok, fail, repeat};
  34:main.c        **** 
  35:main.c        **** /*Structure to hold each x-code*/
  36:main.c        **** struct transition {
  37:main.c        ****     enum state_codes src_state;
  38:main.c        ****     enum ret_codes ret_code;
  39:main.c        ****     enum state_codes dst_state;
  40:main.c        **** };
  41:main.c        **** 
  42:main.c        **** /*Array of transitions, or lookup table with transition rules
  43:main.c        ****  * Each state_transition must contain  one 
  44:main.c        ****  * src_state = which state do we come from.
  45:main.c        ****  * ret_code = what are the current state returning.
  46:main.c        ****  * dst_state = where are we headed next.
  47:main.c        ****  */
  48:main.c        **** struct transition state_transitions[] = {
  49:main.c        ****     {entry, ok, ping},
  50:main.c        ****     {entry, fail, end},
  51:main.c        ****     {ping, ok, send},
  52:main.c        ****     {ping, fail, ping},
  53:main.c        ****     {ping, repeat, ping},
  54:main.c        ****     {send, ok, entry},
  55:main.c        ****     {send, fail, end},
  56:main.c        ****     {send, repeat, send}
  57:main.c        **** };
  58:main.c        **** 
  59:main.c        **** #define EXIT_STATE end
  60:main.c        **** #define ENTRY_STATE entry
  61:main.c        **** #define PORT_ON( port_letter, number )            port_letter |= (1<<number)
  62:main.c        **** #define PORT_OFF( port_letter, number )           port_letter &= ~(1<<number)
  63:main.c        **** #define PORT_ALL_ON( port_letter, number )      port_letter |= (number)
  64:main.c        **** #define PORT_ALL_OFF( port_letter, number )     port_letter &= ~(number)
  65:main.c        **** #define FLIP_PORT( port_letter, number )          port_letter ^= (1<<number)
  66:main.c        **** #define PORT_IS_ON( port_letter, number )       ( port_letter & (1<<number) )
  67:main.c        **** #define PORT_IS_OFF( port_letter, number )      !( port_letter & (1<<number)
  68:main.c        **** 
  69:main.c        **** #define PINGPIN_A    6 
  70:main.c        **** #define PINGPIN_B    7 
  71:main.c        **** #define DDR        DDRD
  72:main.c        **** #define PORT       PORTD
  73:main.c        **** #define PIN        PIND
  74:main.c        **** 
  75:main.c        **** static enum state_codes lookup_transitions(enum state_codes current, enum ret_codes ret) {
  76:main.c        ****     int i = 0;
  77:main.c        ****     enum state_codes temp = end;
  78:main.c        ****     for (i = 0;; ++i) {
  79:main.c        ****         if (state_transitions[i].src_state == current && state_transitions[i].ret_code == ret) {
  80:main.c        ****             temp = state_transitions[i].dst_state;
  81:main.c        ****             break;
  82:main.c        ****         }
  83:main.c        ****     }
  84:main.c        ****     return temp;
  85:main.c        **** }
  86:main.c        **** 
  87:main.c        **** //Globals
  88:main.c        **** volatile uint16_t tot_overflow0;
  89:main.c        **** volatile uint16_t tot_overflow1;
  90:main.c        **** 
  91:main.c        **** //Setup our stream
  92:main.c        **** FILE usart0_str = FDEV_SETUP_STREAM(USART0SendByte, NULL, _FDEV_SETUP_WRITE);
  93:main.c        **** 
  94:main.c        **** // initialize timer, interrupt and variable
  95:main.c        **** void timer0_init(void)
  96:main.c        **** {
  97:main.c        ****     // set up timer with prescaler = 64
  98:main.c        ****     TCCR0B |= (1 << CS00) | (1 << CS01);
  99:main.c        ****   
 100:main.c        ****     // initialize counter
 101:main.c        ****     TCNT0 = 0;
 102:main.c        ****   
 103:main.c        ****     // enable overflow interrupt
 104:main.c        ****     TIMSK0 |= (1 << TOIE0);
 105:main.c        ****   
 106:main.c        ****     // enable global interrupts
 107:main.c        ****     sei();
 108:main.c        ****   
 109:main.c        ****     // initialize overflow counter variable
 110:main.c        ****     tot_overflow0 = 0;
 111:main.c        **** }
 112:main.c        **** 
 113:main.c        **** void timer2_init(void)
 114:main.c        **** {
 115:main.c        ****     // set up timer with prescaler = 64
 116:main.c        ****     TCCR2B |= (1 << CS00) | (1 << CS01);
 117:main.c        ****   
 118:main.c        ****     // initialize counter
 119:main.c        ****     TCNT2 = 0;
 120:main.c        ****   
 121:main.c        ****     // enable overflow interrupt
 122:main.c        ****     TIMSK2 |= (1 << TOIE0);
 123:main.c        ****   
 124:main.c        ****     // initialize overflow counter variable
 125:main.c        ****     tot_overflow1 = 0;
 126:main.c        **** }
 127:main.c        **** void reset_timer_0(void) {
 128:main.c        **** //restart timer count
 129:main.c        **** TCNT0=0x00;//clear timer
 130:main.c        **** //clear timer0's overflow counter.
 131:main.c        **** tot_overflow0 = 0;
 132:main.c        **** }
 133:main.c        **** 
 134:main.c        **** void reset_timer_2(void) {
 135:main.c        **** //restart timer count
 136:main.c        **** TCNT2=0x00;//clear timer
 137:main.c        **** //clear timer0's overflow counter.
 138:main.c        **** tot_overflow1 = 0;
 139:main.c        **** }
 140:main.c        **** int entry_state(void) {
 141:main.c        ****     return ok;
 142:main.c        **** }
 143:main.c        **** 
 144:main.c        **** int ping_state(void) 
 145:main.c        **** {
 146:main.c        ****     double ping_val0,ping_val1;
 147:main.c        **** PORT_ON(DDR, PINGPIN_A);   // Switch PingPin to OUPUT
 148:main.c        **** PORT_ON(DDR, PINGPIN_B);
 149:main.c        **** // ------Trigger Pulse--------------
 150:main.c        **** PORT_OFF(PORT, PINGPIN_A);   // Bring PingPin low before starting trigger pulse
 151:main.c        **** PORT_OFF(PORT, PINGPIN_B); 
 152:main.c        **** _delay_us(2);        //  Wait for 2 microseconds
 153:main.c        **** PORT_ON(PORT, PINGPIN_A);    // Bring PingPin High for 5us according to spec sheet.
 154:main.c        **** PORT_ON(PORT, PINGPIN_B);
 155:main.c        **** _delay_us(5);       // Wait for 5 microseconds
 156:main.c        **** PORT_OFF(PORT, PINGPIN_A); //  Bring PingPin Low and standby
 157:main.c        **** PORT_OFF(PORT, PINGPIN_B);
 158:main.c        **** //--------End Trigger Pulse---------------------
 159:main.c        **** FLIP_PORT(DDR, PINGPIN_A);   // Switch PingPin to INPUT
 160:main.c        **** FLIP_PORT(DDR, PINGPIN_B);
 161:main.c        **** 
 162:main.c        **** loop_until_bit_is_set(PIN, PINGPIN_A);     // Loop until the the PingPin goes high 
 163:main.c        **** loop_until_bit_is_set(PIN, PINGPIN_B);
 164:main.c        **** //clears timer, reset overflow counter
 165:main.c        **** reset_timer_0();       //reset timer 0
 166:main.c        **** reset_timer_2(); 
 167:main.c        **** 
 168:main.c        **** loop_until_bit_is_clear(PIN, PINGPIN_A);     // Loop until the the PingPin goes low 
 169:main.c        **** loop_until_bit_is_clear(PIN, PINGPIN_B);
 170:main.c        **** 
 171:main.c        **** //255 is count before overflow, dependent on clock
 172:main.c        **** int elapsed_time0=tot_overflow0*255+TCNT0;
 173:main.c        **** tot_overflow0 = 0;
 174:main.c        **** ping_val0 = elapsed_time0 * 0.6667;
 175:main.c        **** int elapsed_time1=tot_overflow1*255+TCNT2;
 176:main.c        **** tot_overflow1 = 0;
 177:main.c        **** ping_val1 = elapsed_time1 * 0.6667;
 178:main.c        **** _delay_ms(50);
 179:main.c        **** return fail ? ping_val0 >=900 && ping_val1 >=900 : ok;
 180:main.c        **** }
 181:main.c        **** 
 182:main.c        **** int alarm_state(void) {
 183:main.c        ****     
 184:main.c        ****     return ok;
 185:main.c        **** }
 186:main.c        **** 
 187:main.c        **** int send_state(void) {
 133               	.LM0:
 134               	.LFBB1:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
 188:main.c        ****     printf("A ");
 140               	.LM1:
 141 0000 80E0      		ldi r24,lo8(.LC0)
 142 0002 90E0      		ldi r25,hi8(.LC0)
 143 0004 9F93      		push r25
 144 0006 8F93      		push r24
 145 0008 0E94 0000 		call printf
 189:main.c        ****     return ok;
 147               	.LM2:
 148 000c 0F90      		pop __tmp_reg__
 149 000e 0F90      		pop __tmp_reg__
 190:main.c        **** }
 151               	.LM3:
 152 0010 80E0      		ldi r24,0
 153 0012 90E0      		ldi r25,0
 154 0014 0895      		ret
 156               	.Lscope1:
 157               		.section	.rodata.str1.1
 158               	.LC1:
 159 0003 5765 2068 		.string	"We have a problem :-)"
 159      6176 6520 
 159      6120 7072 
 159      6F62 6C65 
 159      6D20 3A2D 
 160               		.text
 162               	.global	exit_state
 164               	exit_state:
 191:main.c        **** 
 192:main.c        **** int exit_state(void) {
 166               	.LM4:
 167               	.LFBB2:
 168               	/* prologue: function */
 169               	/* frame size = 0 */
 170               	/* stack size = 0 */
 171               	.L__stack_usage = 0
 193:main.c        ****     printf("We have a problem :-)\n");
 173               	.LM5:
 174 0016 80E0      		ldi r24,lo8(.LC1)
 175 0018 90E0      		ldi r25,hi8(.LC1)
 176 001a 0E94 0000 		call puts
 194:main.c        ****     return ok;
 195:main.c        **** }
 178               	.LM6:
 179 001e 80E0      		ldi r24,0
 180 0020 90E0      		ldi r25,0
 181 0022 0895      		ret
 183               	.Lscope2:
 184               	.global	entry_state
 186               	entry_state:
 187               	/* prologue: function */
 188               	/* frame size = 0 */
 189               	/* stack size = 0 */
 190               	.L__stack_usage = 0
 191 0024 80E0      		ldi r24,0
 192 0026 90E0      		ldi r25,0
 193 0028 0895      		ret
 196               	.global	timer0_init
 198               	timer0_init:
  96:main.c        ****     // set up timer with prescaler = 64
 200               	.LM7:
 201               	.LFBB3:
 202               	/* prologue: function */
 203               	/* frame size = 0 */
 204               	/* stack size = 0 */
 205               	.L__stack_usage = 0
  98:main.c        ****   
 207               	.LM8:
 208 002a 85B5      		in r24,0x25
 209 002c 8360      		ori r24,lo8(3)
 210 002e 85BD      		out 0x25,r24
 101:main.c        ****   
 212               	.LM9:
 213 0030 16BC      		out 0x26,__zero_reg__
 104:main.c        ****   
 215               	.LM10:
 216 0032 EEE6      		ldi r30,lo8(110)
 217 0034 F0E0      		ldi r31,0
 218 0036 8081      		ld r24,Z
 219 0038 8160      		ori r24,lo8(1)
 220 003a 8083      		st Z,r24
 107:main.c        ****   
 222               	.LM11:
 223               	/* #APP */
 224               	 ;  107 "main.c" 1
 225 003c 7894      		sei
 226               	 ;  0 "" 2
 110:main.c        **** }
 228               	.LM12:
 229               	/* #NOAPP */
 230 003e 1092 0000 		sts tot_overflow0+1,__zero_reg__
 231 0042 1092 0000 		sts tot_overflow0,__zero_reg__
 232 0046 0895      		ret
 234               	.Lscope3:
 236               	.global	timer2_init
 238               	timer2_init:
 114:main.c        ****     // set up timer with prescaler = 64
 240               	.LM13:
 241               	.LFBB4:
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
 116:main.c        ****   
 247               	.LM14:
 248 0048 E1EB      		ldi r30,lo8(-79)
 249 004a F0E0      		ldi r31,0
 250 004c 8081      		ld r24,Z
 251 004e 8360      		ori r24,lo8(3)
 252 0050 8083      		st Z,r24
 119:main.c        ****   
 254               	.LM15:
 255 0052 1092 B200 		sts 178,__zero_reg__
 122:main.c        ****   
 257               	.LM16:
 258 0056 E0E7      		ldi r30,lo8(112)
 259 0058 F0E0      		ldi r31,0
 260 005a 8081      		ld r24,Z
 261 005c 8160      		ori r24,lo8(1)
 262 005e 8083      		st Z,r24
 125:main.c        **** }
 264               	.LM17:
 265 0060 1092 0000 		sts tot_overflow1+1,__zero_reg__
 266 0064 1092 0000 		sts tot_overflow1,__zero_reg__
 267 0068 0895      		ret
 269               	.Lscope4:
 271               	.global	reset_timer_0
 273               	reset_timer_0:
 127:main.c        **** //restart timer count
 275               	.LM18:
 276               	.LFBB5:
 277               	/* prologue: function */
 278               	/* frame size = 0 */
 279               	/* stack size = 0 */
 280               	.L__stack_usage = 0
 129:main.c        **** //clear timer0's overflow counter.
 282               	.LM19:
 283 006a 16BC      		out 0x26,__zero_reg__
 131:main.c        **** }
 285               	.LM20:
 286 006c 1092 0000 		sts tot_overflow0+1,__zero_reg__
 287 0070 1092 0000 		sts tot_overflow0,__zero_reg__
 288 0074 0895      		ret
 290               	.Lscope5:
 292               	.global	reset_timer_2
 294               	reset_timer_2:
 134:main.c        **** //restart timer count
 296               	.LM21:
 297               	.LFBB6:
 298               	/* prologue: function */
 299               	/* frame size = 0 */
 300               	/* stack size = 0 */
 301               	.L__stack_usage = 0
 136:main.c        **** //clear timer0's overflow counter.
 303               	.LM22:
 304 0076 1092 B200 		sts 178,__zero_reg__
 138:main.c        **** }
 306               	.LM23:
 307 007a 1092 0000 		sts tot_overflow1+1,__zero_reg__
 308 007e 1092 0000 		sts tot_overflow1,__zero_reg__
 309 0082 0895      		ret
 311               	.Lscope6:
 312               	.global	__floatsisf
 313               	.global	__mulsf3
 314               	.global	__gesf2
 316               	.global	ping_state
 318               	ping_state:
 145:main.c        ****     double ping_val0,ping_val1;
 320               	.LM24:
 321               	.LFBB7:
 322 0084 0F93      		push r16
 323 0086 1F93      		push r17
 324 0088 CF93      		push r28
 325 008a DF93      		push r29
 326               	/* prologue: function */
 327               	/* frame size = 0 */
 328               	/* stack size = 4 */
 329               	.L__stack_usage = 4
 147:main.c        **** PORT_ON(DDR, PINGPIN_B);
 331               	.LM25:
 332 008c 569A      		sbi 0xa,6
 148:main.c        **** // ------Trigger Pulse--------------
 334               	.LM26:
 335 008e 579A      		sbi 0xa,7
 150:main.c        **** PORT_OFF(PORT, PINGPIN_B); 
 337               	.LM27:
 338 0090 5E98      		cbi 0xb,6
 151:main.c        **** _delay_us(2);        //  Wait for 2 microseconds
 340               	.LM28:
 341 0092 5F98      		cbi 0xb,7
 342               	.LBB8:
 343               	.LBB9:
 345               	.Ltext1:
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2453 2014-10-19 08:18:11Z saaadhu $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/avr/include/util/delay.h **** #endif
  41:/usr/avr/include/util/delay.h **** 
  42:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/avr/include/util/delay.h **** #include <math.h>
  45:/usr/avr/include/util/delay.h **** 
  46:/usr/avr/include/util/delay.h **** /** \file */
  47:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/avr/include/util/delay.h ****     \code
  49:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/avr/include/util/delay.h ****     \endcode
  53:/usr/avr/include/util/delay.h **** 
  54:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/avr/include/util/delay.h ****     used.
  58:/usr/avr/include/util/delay.h **** 
  59:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/avr/include/util/delay.h **** 
  68:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/avr/include/util/delay.h **** 
  77:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/avr/include/util/delay.h **** 
  81:/usr/avr/include/util/delay.h **** */
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  85:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  86:/usr/avr/include/util/delay.h **** #endif
  87:/usr/avr/include/util/delay.h **** 
  88:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/avr/include/util/delay.h **** #endif
  93:/usr/avr/include/util/delay.h **** 
  94:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/avr/include/util/delay.h **** #endif
  97:/usr/avr/include/util/delay.h **** 
  98:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/avr/include/util/delay.h **** #endif
 103:/usr/avr/include/util/delay.h **** 
 104:/usr/avr/include/util/delay.h **** /**
 105:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/avr/include/util/delay.h **** 
 107:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/avr/include/util/delay.h **** 
 109:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/avr/include/util/delay.h **** 
 112:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/avr/include/util/delay.h **** 
 114:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/avr/include/util/delay.h **** 
 120:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/avr/include/util/delay.h **** 
 125:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/avr/include/util/delay.h **** 
 132:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/avr/include/util/delay.h **** 
 140:/usr/avr/include/util/delay.h ****  */
 141:/usr/avr/include/util/delay.h **** void
 142:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/avr/include/util/delay.h **** {
 144:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 145:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 146:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 147:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 148:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 149:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 150:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 153:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 154:/usr/avr/include/util/delay.h **** 
 155:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 156:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 157:/usr/avr/include/util/delay.h **** 
 158:/usr/avr/include/util/delay.h **** 	#else
 159:/usr/avr/include/util/delay.h **** 		//round up by default
 160:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 161:/usr/avr/include/util/delay.h **** 	#endif
 162:/usr/avr/include/util/delay.h **** 
 163:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 164:/usr/avr/include/util/delay.h **** 
 165:/usr/avr/include/util/delay.h **** #else
 166:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 167:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/avr/include/util/delay.h **** 	{
 172:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/avr/include/util/delay.h **** 		{
 176:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/avr/include/util/delay.h **** 		}
 180:/usr/avr/include/util/delay.h **** 		return;
 181:/usr/avr/include/util/delay.h **** 	}
 182:/usr/avr/include/util/delay.h **** 	else
 183:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/avr/include/util/delay.h **** #endif
 186:/usr/avr/include/util/delay.h **** }
 187:/usr/avr/include/util/delay.h **** 
 188:/usr/avr/include/util/delay.h **** /**
 189:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/avr/include/util/delay.h **** 
 191:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/avr/include/util/delay.h **** 
 193:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/avr/include/util/delay.h **** 
 196:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/avr/include/util/delay.h **** 
 198:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/avr/include/util/delay.h **** 
 202:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/avr/include/util/delay.h ****   
 207:/usr/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/avr/include/util/delay.h **** 
 211:/usr/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/avr/include/util/delay.h ****  
 214:/usr/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****  */
 223:/usr/avr/include/util/delay.h **** void
 224:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/avr/include/util/delay.h **** {
 226:/usr/avr/include/util/delay.h **** 	double __tmp ; 
 227:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 228:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 229:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 230:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 231:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 232:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 233:/usr/avr/include/util/delay.h **** 
 234:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 235:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 236:/usr/avr/include/util/delay.h **** 
 237:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 238:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 239:/usr/avr/include/util/delay.h **** 
 240:/usr/avr/include/util/delay.h **** 	#else
 241:/usr/avr/include/util/delay.h **** 		//round up by default
 242:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 243:/usr/avr/include/util/delay.h **** 	#endif
 244:/usr/avr/include/util/delay.h **** 
 245:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 347               	.LM29:
 348 0094 4AE0      		ldi r20,lo8(10)
 349 0096 4A95      	1:	dec r20
 350 0098 01F4      		brne 1b
 351 009a 00C0      		rjmp .
 352               	.LBE9:
 353               	.LBE8:
 355               	.Ltext2:
 153:main.c        **** PORT_ON(PORT, PINGPIN_B);
 357               	.LM30:
 358 009c 5E9A      		sbi 0xb,6
 154:main.c        **** _delay_us(5);       // Wait for 5 microseconds
 360               	.LM31:
 361 009e 5F9A      		sbi 0xb,7
 362               	.LBB10:
 363               	.LBB11:
 365               	.Ltext3:
 367               	.LM32:
 368 00a0 5AE1      		ldi r21,lo8(26)
 369 00a2 5A95      	1:	dec r21
 370 00a4 01F4      		brne 1b
 371 00a6 00C0      		rjmp .
 372               	.LBE11:
 373               	.LBE10:
 375               	.Ltext4:
 156:main.c        **** PORT_OFF(PORT, PINGPIN_B);
 377               	.LM33:
 378 00a8 5E98      		cbi 0xb,6
 157:main.c        **** //--------End Trigger Pulse---------------------
 380               	.LM34:
 381 00aa 5F98      		cbi 0xb,7
 159:main.c        **** FLIP_PORT(DDR, PINGPIN_B);
 383               	.LM35:
 384 00ac 9AB1      		in r25,0xa
 385 00ae 80E4      		ldi r24,lo8(64)
 386 00b0 8927      		eor r24,r25
 387 00b2 8AB9      		out 0xa,r24
 160:main.c        **** 
 389               	.LM36:
 390 00b4 8AB1      		in r24,0xa
 391 00b6 8058      		subi r24,lo8(-(-128))
 392 00b8 8AB9      		out 0xa,r24
 393               	.L9:
 162:main.c        **** loop_until_bit_is_set(PIN, PINGPIN_B);
 395               	.LM37:
 396 00ba 4E9B      		sbis 0x9,6
 397 00bc 00C0      		rjmp .L9
 398               	.L19:
 163:main.c        **** //clears timer, reset overflow counter
 400               	.LM38:
 401 00be 4F9B      		sbis 0x9,7
 402 00c0 00C0      		rjmp .L19
 165:main.c        **** reset_timer_2(); 
 404               	.LM39:
 405 00c2 0E94 0000 		call reset_timer_0
 166:main.c        **** 
 407               	.LM40:
 408 00c6 0E94 0000 		call reset_timer_2
 409               	.L11:
 168:main.c        **** loop_until_bit_is_clear(PIN, PINGPIN_B);
 411               	.LM41:
 412 00ca 4E99      		sbic 0x9,6
 413 00cc 00C0      		rjmp .L11
 414               	.L12:
 169:main.c        **** 
 416               	.LM42:
 417 00ce 4F99      		sbic 0x9,7
 418 00d0 00C0      		rjmp .L12
 172:main.c        **** tot_overflow0 = 0;
 420               	.LM43:
 421 00d2 2091 0000 		lds r18,tot_overflow0
 422 00d6 3091 0000 		lds r19,tot_overflow0+1
 423 00da 86B5      		in r24,0x26
 173:main.c        **** ping_val0 = elapsed_time0 * 0.6667;
 425               	.LM44:
 426 00dc 1092 0000 		sts tot_overflow0+1,__zero_reg__
 427 00e0 1092 0000 		sts tot_overflow0,__zero_reg__
 175:main.c        **** tot_overflow1 = 0;
 429               	.LM45:
 430 00e4 C091 0000 		lds r28,tot_overflow1
 431 00e8 D091 0000 		lds r29,tot_overflow1+1
 432 00ec 0091 B200 		lds r16,178
 176:main.c        **** ping_val1 = elapsed_time1 * 0.6667;
 434               	.LM46:
 435 00f0 1092 0000 		sts tot_overflow1+1,__zero_reg__
 436 00f4 1092 0000 		sts tot_overflow1,__zero_reg__
 437               	.LBB12:
 438               	.LBB13:
 440               	.Ltext5:
 163:/usr/avr/include/util/delay.h **** 
 442               	.LM47:
 443 00f8 9FEF      		ldi r25,lo8(159999)
 444 00fa 40E7      		ldi r20,hi8(159999)
 445 00fc 52E0      		ldi r21,hlo8(159999)
 446 00fe 9150      	1:	subi r25,1
 447 0100 4040      		sbci r20,0
 448 0102 5040      		sbci r21,0
 449 0104 01F4      		brne 1b
 450 0106 00C0      		rjmp .
 451 0108 0000      		nop
 452               	.LBE13:
 453               	.LBE12:
 455               	.Ltext6:
 179:main.c        **** }
 457               	.LM48:
 458 010a 1FEF      		ldi r17,lo8(-1)
 459 010c 129F      		mul r17,r18
 460 010e B001      		movw r22,r0
 461 0110 139F      		mul r17,r19
 462 0112 700D      		add r23,r0
 463 0114 1124      		clr __zero_reg__
 464 0116 680F      		add r22,r24
 465 0118 711D      		adc r23,__zero_reg__
 466 011a 072E      		mov __tmp_reg__,r23
 467 011c 000C      		lsl r0
 468 011e 880B      		sbc r24,r24
 469 0120 990B      		sbc r25,r25
 470 0122 0E94 0000 		call __floatsisf
 471 0126 2AED      		ldi r18,lo8(-38)
 472 0128 3CEA      		ldi r19,lo8(-84)
 473 012a 4AE2      		ldi r20,lo8(42)
 474 012c 5FE3      		ldi r21,lo8(63)
 475 012e 0E94 0000 		call __mulsf3
 476 0132 20E0      		ldi r18,0
 477 0134 30E0      		ldi r19,0
 478 0136 41E6      		ldi r20,lo8(97)
 479 0138 54E4      		ldi r21,lo8(68)
 480 013a 0E94 0000 		call __gesf2
 481 013e 87FD      		sbrc r24,7
 482 0140 00C0      		rjmp .L24
 179:main.c        **** }
 484               	.LM49:
 485 0142 1C9F      		mul r17,r28
 486 0144 B001      		movw r22,r0
 487 0146 1D9F      		mul r17,r29
 488 0148 700D      		add r23,r0
 489 014a 1124      		clr __zero_reg__
 490 014c 600F      		add r22,r16
 491 014e 711D      		adc r23,__zero_reg__
 492 0150 072E      		mov __tmp_reg__,r23
 493 0152 000C      		lsl r0
 494 0154 880B      		sbc r24,r24
 495 0156 990B      		sbc r25,r25
 496 0158 0E94 0000 		call __floatsisf
 497 015c 2AED      		ldi r18,lo8(-38)
 498 015e 3CEA      		ldi r19,lo8(-84)
 499 0160 4AE2      		ldi r20,lo8(42)
 500 0162 5FE3      		ldi r21,lo8(63)
 501 0164 0E94 0000 		call __mulsf3
 502 0168 D1E0      		ldi r29,lo8(1)
 503 016a C0E0      		ldi r28,0
 504 016c 20E0      		ldi r18,0
 505 016e 30E0      		ldi r19,0
 506 0170 41E6      		ldi r20,lo8(97)
 507 0172 54E4      		ldi r21,lo8(68)
 508 0174 0E94 0000 		call __gesf2
 509 0178 87FD      		sbrc r24,7
 510 017a D0E0      		ldi r29,0
 511               	.L15:
 512 017c 8D2F      		mov r24,r29
 513 017e 9C2F      		mov r25,r28
 514 0180 00C0      		rjmp .L13
 515               	.L24:
 179:main.c        **** }
 517               	.LM50:
 518 0182 80E0      		ldi r24,0
 519 0184 90E0      		ldi r25,0
 520               	.L13:
 521               	/* epilogue start */
 180:main.c        **** 
 523               	.LM51:
 524 0186 DF91      		pop r29
 525 0188 CF91      		pop r28
 526 018a 1F91      		pop r17
 527 018c 0F91      		pop r16
 528 018e 0895      		ret
 530               	.Lscope7:
 532               	.global	alarm_state
 534               	alarm_state:
 182:main.c        ****     
 536               	.LM52:
 537               	.LFBB8:
 538               	/* prologue: function */
 539               	/* frame size = 0 */
 540               	/* stack size = 0 */
 541               	.L__stack_usage = 0
 185:main.c        **** 
 543               	.LM53:
 544 0190 80E0      		ldi r24,0
 545 0192 90E0      		ldi r25,0
 546 0194 0895      		ret
 548               	.Lscope8:
 549               		.section	.text.startup,"ax",@progbits
 553               	.global	main
 555               	main:
 196:main.c        **** 
 197:main.c        **** /*
 198:main.c        ****  * 
 199:main.c        ****  */
 200:main.c        **** int main(int argc, char** argv) {
 557               	.LM54:
 558               	.LFBB9:
 559 0000 CF93      		push r28
 560               	/* prologue: function */
 561               	/* frame size = 0 */
 562               	/* stack size = 1 */
 563               	.L__stack_usage = 1
 201:main.c        **** 
 202:main.c        ****     enum state_codes cur_state = ENTRY_STATE;
 203:main.c        ****     enum ret_codes rc;
 204:main.c        ****     int (* state_fun)(void);
 205:main.c        ****     //Init UART
 206:main.c        ****     USART0Init();
 565               	.LM55:
 566 0002 0E94 0000 		call USART0Init
 207:main.c        ****     //Init timers
 208:main.c        ****     timer0_init();
 568               	.LM56:
 569 0006 0E94 0000 		call timer0_init
 209:main.c        ****     timer2_init();
 571               	.LM57:
 572 000a 0E94 0000 		call timer2_init
 210:main.c        ****     //assign our stream to standart I/O streams
 211:main.c        ****     stdin = stdout = &usart0_str;
 574               	.LM58:
 575 000e 80E0      		ldi r24,lo8(usart0_str)
 576 0010 90E0      		ldi r25,hi8(usart0_str)
 577 0012 9093 0000 		sts __iob+2+1,r25
 578 0016 8093 0000 		sts __iob+2,r24
 579 001a 9093 0000 		sts __iob+1,r25
 580 001e 8093 0000 		sts __iob,r24
 202:main.c        ****     enum ret_codes rc;
 582               	.LM59:
 583 0022 C0E0      		ldi r28,0
 584               	.L30:
 212:main.c        ****     
 213:main.c        ****     for (;;) {
 214:main.c        ****         state_fun = state[cur_state];
 586               	.LM60:
 587 0024 EC2F      		mov r30,r28
 588 0026 F0E0      		ldi r31,0
 589 0028 EE0F      		lsl r30
 590 002a FF1F      		rol r31
 591 002c E050      		subi r30,lo8(-(state))
 592 002e F040      		sbci r31,hi8(-(state))
 215:main.c        ****         rc = state_fun();
 594               	.LM61:
 595 0030 0190      		ld __tmp_reg__,Z+
 596 0032 F081      		ld r31,Z
 597 0034 E02D      		mov r30,__tmp_reg__
 598 0036 0995      		icall
 216:main.c        ****         if (EXIT_STATE == cur_state)
 600               	.LM62:
 601 0038 C330      		cpi r28,lo8(3)
 602 003a 01F0      		breq .L28
 603 003c E0E0      		ldi r30,lo8(state_transitions)
 604 003e F0E0      		ldi r31,hi8(state_transitions)
 605 0040 20E0      		ldi r18,0
 606 0042 30E0      		ldi r19,0
 607               	.L31:
 608               	.LBB16:
 609               	.LBB17:
  79:main.c        ****             temp = state_transitions[i].dst_state;
 611               	.LM63:
 612 0044 9081      		ld r25,Z
 613 0046 C913      		cpse r28,r25
 614 0048 00C0      		rjmp .L29
 615 004a 9181      		ldd r25,Z+1
 616 004c 8913      		cpse r24,r25
 617 004e 00C0      		rjmp .L29
  80:main.c        ****             break;
 619               	.LM64:
 620 0050 F901      		movw r30,r18
 621 0052 EE0F      		lsl r30
 622 0054 FF1F      		rol r31
 623 0056 2E0F      		add r18,r30
 624 0058 3F1F      		adc r19,r31
 625 005a F901      		movw r30,r18
 626 005c E050      		subi r30,lo8(-(state_transitions))
 627 005e F040      		sbci r31,hi8(-(state_transitions))
 628 0060 C281      		ldd r28,Z+2
 629               	.LBE17:
 630               	.LBE16:
 217:main.c        ****             break;
 218:main.c        ****         cur_state = lookup_transitions(cur_state, rc);
 219:main.c        ****     }
 632               	.LM65:
 633 0062 00C0      		rjmp .L30
 634               	.L29:
 635               	.LBB19:
 636               	.LBB18:
  78:main.c        ****         if (state_transitions[i].src_state == current && state_transitions[i].ret_code == ret) {
 638               	.LM66:
 639 0064 2F5F      		subi r18,-1
 640 0066 3F4F      		sbci r19,-1
 641 0068 3396      		adiw r30,3
 642 006a 00C0      		rjmp .L31
 643               	.L28:
 644               	.LBE18:
 645               	.LBE19:
 220:main.c        **** 
 221:main.c        ****     return (EXIT_SUCCESS);
 222:main.c        **** }
 647               	.LM67:
 648 006c 80E0      		ldi r24,0
 649 006e 90E0      		ldi r25,0
 650               	/* epilogue start */
 651 0070 CF91      		pop r28
 652 0072 0895      		ret
 664               	.Lscope9:
 665               		.text
 667               	.global	__vector_16
 669               	__vector_16:
 223:main.c        **** 
 224:main.c        **** // TIMER0 overflow interrupt service routine
 225:main.c        **** // called whenever TCNT0 overflows
 226:main.c        **** ISR(TIMER0_OVF_vect)
 227:main.c        **** {
 671               	.LM68:
 672               	.LFBB10:
 673 0196 1F92      		push r1
 674 0198 0F92      		push r0
 675 019a 0FB6      		in r0,__SREG__
 676 019c 0F92      		push r0
 677 019e 1124      		clr __zero_reg__
 678 01a0 8F93      		push r24
 679 01a2 9F93      		push r25
 680               	/* prologue: Signal */
 681               	/* frame size = 0 */
 682               	/* stack size = 5 */
 683               	.L__stack_usage = 5
 228:main.c        ****     // keep a track of number of overflows
 229:main.c        ****     tot_overflow0++;
 685               	.LM69:
 686 01a4 8091 0000 		lds r24,tot_overflow0
 687 01a8 9091 0000 		lds r25,tot_overflow0+1
 688 01ac 0196      		adiw r24,1
 689 01ae 9093 0000 		sts tot_overflow0+1,r25
 690 01b2 8093 0000 		sts tot_overflow0,r24
 691               	/* epilogue start */
 230:main.c        **** }
 693               	.LM70:
 694 01b6 9F91      		pop r25
 695 01b8 8F91      		pop r24
 696 01ba 0F90      		pop r0
 697 01bc 0FBE      		out __SREG__,r0
 698 01be 0F90      		pop r0
 699 01c0 1F90      		pop r1
 700 01c2 1895      		reti
 702               	.Lscope10:
 704               	.global	__vector_9
 706               	__vector_9:
 231:main.c        **** 
 232:main.c        **** // TIMER2 overflow interrupt service routine
 233:main.c        **** // called whenever TCNT2 overflows
 234:main.c        **** ISR(TIMER2_OVF_vect)
 235:main.c        **** {
 708               	.LM71:
 709               	.LFBB11:
 710 01c4 1F92      		push r1
 711 01c6 0F92      		push r0
 712 01c8 0FB6      		in r0,__SREG__
 713 01ca 0F92      		push r0
 714 01cc 1124      		clr __zero_reg__
 715 01ce 8F93      		push r24
 716 01d0 9F93      		push r25
 717               	/* prologue: Signal */
 718               	/* frame size = 0 */
 719               	/* stack size = 5 */
 720               	.L__stack_usage = 5
 236:main.c        ****     // keep a track of number of overflows
 237:main.c        ****     tot_overflow1++;
 722               	.LM72:
 723 01d2 8091 0000 		lds r24,tot_overflow1
 724 01d6 9091 0000 		lds r25,tot_overflow1+1
 725 01da 0196      		adiw r24,1
 726 01dc 9093 0000 		sts tot_overflow1+1,r25
 727 01e0 8093 0000 		sts tot_overflow1,r24
 728               	/* epilogue start */
 238:main.c        **** }
 730               	.LM73:
 731 01e4 9F91      		pop r25
 732 01e6 8F91      		pop r24
 733 01e8 0F90      		pop r0
 734 01ea 0FBE      		out __SREG__,r0
 735 01ec 0F90      		pop r0
 736 01ee 1F90      		pop r1
 737 01f0 1895      		reti
 739               	.Lscope11:
 740               	.global	usart0_str
 741               		.data
 744               	usart0_str:
 745 0000 0000 00   		.zero	3
 746 0003 02        		.byte	2
 747 0004 0000 0000 		.zero	4
 748 0008 0000      		.word	gs(USART0SendByte)
 749 000a 0000      		.word	0
 750 000c 0000      		.word	0
 751               		.comm	tot_overflow1,2,1
 752               		.comm	tot_overflow0,2,1
 753               	.global	state_transitions
 756               	state_transitions:
 757 000e 00        		.byte	0
 758 000f 00        		.byte	0
 759 0010 01        		.byte	1
 760 0011 00        		.byte	0
 761 0012 01        		.byte	1
 762 0013 03        		.byte	3
 763 0014 01        		.byte	1
 764 0015 00        		.byte	0
 765 0016 02        		.byte	2
 766 0017 01        		.byte	1
 767 0018 01        		.byte	1
 768 0019 01        		.byte	1
 769 001a 01        		.byte	1
 770 001b 02        		.byte	2
 771 001c 01        		.byte	1
 772 001d 02        		.byte	2
 773 001e 00        		.byte	0
 774 001f 00        		.byte	0
 775 0020 02        		.byte	2
 776 0021 01        		.byte	1
 777 0022 03        		.byte	3
 778 0023 02        		.byte	2
 779 0024 02        		.byte	2
 780 0025 02        		.byte	2
 781               	.global	state
 784               	state:
 785 0026 0000      		.word	gs(entry_state)
 786 0028 0000      		.word	gs(ping_state)
 787 002a 0000      		.word	gs(send_state)
 788 002c 0000      		.word	gs(exit_state)
 794               		.text
 796               	.Letext0:
 797               		.ident	"GCC: (GNU) 5.3.0"
 798               	.global __do_copy_data
 799               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc51FgX0.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc51FgX0.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc51FgX0.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc51FgX0.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc51FgX0.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc51FgX0.s:131    .text:0000000000000000 send_state
     /tmp/cc51FgX0.s:164    .text:0000000000000016 exit_state
     /tmp/cc51FgX0.s:186    .text:0000000000000024 entry_state
     /tmp/cc51FgX0.s:198    .text:000000000000002a timer0_init
                            *COM*:0000000000000002 tot_overflow0
     /tmp/cc51FgX0.s:238    .text:0000000000000048 timer2_init
                            *COM*:0000000000000002 tot_overflow1
     /tmp/cc51FgX0.s:273    .text:000000000000006a reset_timer_0
     /tmp/cc51FgX0.s:294    .text:0000000000000076 reset_timer_2
     /tmp/cc51FgX0.s:318    .text:0000000000000084 ping_state
     /tmp/cc51FgX0.s:534    .text:0000000000000190 alarm_state
     /tmp/cc51FgX0.s:555    .text.startup:0000000000000000 main
     /tmp/cc51FgX0.s:744    .data:0000000000000000 usart0_str
     /tmp/cc51FgX0.s:784    .data:0000000000000026 state
     /tmp/cc51FgX0.s:756    .data:000000000000000e state_transitions
     /tmp/cc51FgX0.s:669    .text:0000000000000196 __vector_16
     /tmp/cc51FgX0.s:706    .text:00000000000001c4 __vector_9

UNDEFINED SYMBOLS
printf
puts
__floatsisf
__mulsf3
__gesf2
USART0Init
__iob
USART0SendByte
__do_copy_data
__do_clear_bss
